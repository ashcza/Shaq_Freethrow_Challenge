<html>
  <head>
    <script src="https://code.createjs.com/createjs-2015.11.26.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.10.0/matter.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script>

    class Ball {

      constructor(stage, force, physics) {
        console.log("constructor");

        // adds the ball to the physics engine (x, y, radius)
        this.physics = physics;
        this.body = physics.Bodies.circle(50, 200, 15)
        physics.World.add(physics.engine.world, [this.body]);
        this.addForce(force, -.026);
        this.body.restitution = .84;
        this.shape = new createjs.Shape();
        this.stage = stage;
        stage.addChild(this.shape);
      }

      addForce(dx, dy) {
        this.physics.Matter.Body.applyForce(this.body, this.body.position, {x: dx, y: dy});
            }

      step() {
      };

      draw() {
        this.shape.graphics.beginFill("DeepSkyBlue").drawCircle(0, 0, 15);
        this.shape.x = this.body.position.x;
        this.shape.y = this.body.position.y;
      };
    }

    class PhysicsWrapper {
      constructor() {
        this.Engine = Matter.Engine;
        this.Render = Matter.Render;
        this.World = Matter.World;
        this.Bodies = Matter.Bodies;
        this.Matter = Matter;
        // create an engine
        this.engine = this.Engine.create();
        this.engine.world.gravity.y = 1;

        // create a renderer
        this.render = this.Render.create({
          element: document.body,
          engine: this.engine
        });
        // run the renderer
        this.Render.run(this.render);
      }

      step () {
        //step forward the physics engine
        this.Engine.update(this.engine);
      }

      draw () {
      }

    }

    class Hoop {
      constructor(physics, ballArray) {
        // create backboard and ground
        var pole = physics.Bodies.rectangle(650, 150, 20, 150, {isStatic: true});
        var rim1 = physics.Bodies.rectangle(635, 200, 10, 5, { isStatic: true });
        var rim2 = physics.Bodies.rectangle(580, 200, 5, 5, { isStatic: true });
        var ground = physics.Bodies.rectangle(400, 480, 810, 60, { isStatic: true });
        // add all of the bodies to the world
        physics.World.add(physics.engine.world, [pole, rim1, rim2, ground]);
        this.physics = physics;
        this.ballArray = ballArray;
        this.basketsMade = [];
      }
      step () {
        //Checks to see if ball exists
        if (this.physics.engine.world.bodies[4]) {
        //Checks to see if basket was made
          for (var i = 0; i < this.ballArray.length; i++) {
            if (this.physics.Matter.Bounds.contains(this.ballArray[i].body.bounds, {x: 600, y: 220})) {
              console.log("Basket Made");
              if (!this.basketsMade.includes(this.ballArray[i].body.id)) {
                this.basketsMade.push(this.ballArray[i].body.id);
              }
            }
          }

        }
      }
      draw () {
      }
    }

      function game() {


        var physicsWrapper = new PhysicsWrapper();
        var stage = new createjs.Stage("demoCanvas");

        var queue = [];
        var ballArray = [];
        var hoop = new Hoop(physicsWrapper, ballArray);
        queue.push(physicsWrapper);
        queue.push(hoop);


        function shootBall () {
          var ball = new Ball(stage, .0315, physicsWrapper)
          ballArray.push(ball);
          queue.push(ball);
        }

        function getShotsMade(hoop) {
          hoop.basketsMade.count;
        }


        // Matter.World.remove(engine.world, engine.world.bodies[4])


        $(window).keypress(function (e) {
          if (e.keyCode === 0 || e.keyCode === 32) {
            e.preventDefault()
            shootBall();
          }
        })





        // stage.update();

        //Update stage will render next frame
        createjs.Ticker.addEventListener("tick", handleTick);

        function handleTick() {

          for(var i = 0; i < queue.length; i+=1) {
            queue[i].step();
          }

          for(var i = 0; i < queue.length; i+=1) {
            queue[i].draw();
          }



          //update canvas according to new physics engine calculations
          stage.update();
        }
      }

    </script>
  </head>
  <body onload="game();">
    <canvas id="demoCanvas" width="640" height="480"></canvas>

  </body>
</html>
